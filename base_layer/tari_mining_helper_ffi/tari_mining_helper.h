// Copyright 2024. The Tari Project
// SPDX-License-Identifier: BSD-3-Clause

// This file was generated by cargo-bindgen. Please do not edit manually.

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

/**
 * The latest version of the Identity Signature.
 */
#define IdentitySignature_LATEST_VERSION 0

struct ByteVector;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Creates a ByteVector
 *
 * ## Arguments
 * `byte_array` - The pointer to the byte array
 * `element_count` - The number of elements in byte_array
 * `error_out` - Pointer to an int which will be modified to an error code should one occur, may not be null. Functions
 * as an out parameter.
 *
 * ## Returns
 * `*mut ByteVector` - Pointer to the created ByteVector. Note that it will be ptr::null_mut()
 * if the byte_array pointer was null or if the elements in the byte_vector don't match
 * element_count when it is created
 *
 * # Safety
 * The ```byte_vector_destroy``` function must be called when finished with a ByteVector to prevent a memory leak
 */
struct ByteVector *byte_vector_create(const unsigned char *byte_array,
                                      unsigned int element_count,
                                      int *error_out);

/**
 * Frees memory for a ByteVector
 *
 * ## Arguments
 * `bytes` - The pointer to a ByteVector
 *
 * ## Returns
 * `()` - Does not return a value, equivalent to void in C
 *
 * # Safety
 * None
 */
void byte_vector_destroy(struct ByteVector *bytes);

/**
 * Gets a c_uchar at position in a ByteVector
 *
 * ## Arguments
 * `ptr` - The pointer to a ByteVector
 * `position` - The integer position
 * `error_out` - Pointer to an int which will be modified to an error code should one occur, may not be null. Functions
 * as an out parameter.
 *
 * ## Returns
 * `c_uchar` - Returns a character. Note that the character will be a null terminator (0) if ptr
 * is null or if the position is invalid
 *
 * # Safety
 * None
 */
unsigned char byte_vector_get_at(struct ByteVector *ptr,
                                 unsigned int position,
                                 int *error_out);

/**
 * Gets the number of elements in a ByteVector
 *
 * ## Arguments
 * `ptr` - The pointer to a ByteVector
 * `error_out` - Pointer to an int which will be modified to an error code should one occur, may not be null. Functions
 * as an out parameter.
 *
 * ## Returns
 * `c_uint` - Returns the integer number of elements in the ByteVector. Note that it will be zero
 * if ptr is null
 *
 * # Safety
 * None
 */
unsigned int byte_vector_get_length(const struct ByteVector *vec,
                                    int *error_out);

/**
 * Validates a hex string is convertible into a TariPublicKey
 *
 * ## Arguments
 * `hex` - The hex formatted cstring to be validated
 *
 * ## Returns
 * `bool` - Returns true/false
 * `error_out` - Error code returned, 0 means no error
 *
 * # Safety
 * None
 */
bool public_key_hex_validate(const char *hex, int *error_out);

/**
 * Injects a nonce into a blocktemplate
 *
 * ## Arguments
 * `hex` - The hex formatted cstring
 * `nonce` - The nonce to be injected
 *
 * ## Returns
 * `c_char` - The updated hex formatted cstring or null on error
 * `error_out` - Error code returned, 0 means no error
 *
 * # Safety
 * None
 */
void inject_nonce(struct ByteVector *header, unsigned long long nonce, int *error_out);

/**
 * Injects a coinbase into a blocktemplate
 *
 * ## Arguments
 * `block_template_bytes` - The block template as bytes, serialized with borsh.io
 * `value` - The value of the coinbase
 * `stealth_payment` - Boolean value, is this a stealh payment or normal one-sided
 * `revealed_value_proof` - Boolean value, should this use the reveal value proof, or BP+
 * `wallet_payment_address` - The address to pay the coinbase to
 * `coinbase_extra` - The value of the coinbase extra field
 * `network` - The value of the network
 *
 * ## Returns
 * `block_template_bytes` - The updated block template
 * `error_out` - Error code returned, 0 means no error
 *
 * # Safety
 * None
 */
void inject_coinbase(struct ByteVector *block_template_bytes,
                     unsigned long long coibase_value,
                     bool stealth_payment,
                     bool revealed_value_proof,
                     const char *wallet_payment_address,
                     const char *coinbase_extra,
                     unsigned int network,
                     int *error_out);

/**
 * Returns the difficulty of a share
 *
 * ## Arguments
 * `hex` - The hex formatted cstring to be validated
 *
 * ## Returns
 * `c_ulonglong` - Difficulty, 0 on error
 * `error_out` - Error code returned, 0 means no error
 *
 * # Safety
 * None
 */
unsigned long long share_difficulty(struct ByteVector *header,
                                    unsigned int network,
                                    int *error_out);

/**
 * Validates a share submission
 *
 * ## Arguments
 * `hex` - The hex representation of the share to be validated
 * `hash` - The hash of the share to be validated
 * `nonce` - The nonce for the share to be validated
 * `stratum_difficulty` - The stratum difficulty to be checked against (meeting this means that the share is valid for
 * payout) `template_difficulty` - The difficulty to be checked against (meeting this means the share is also a block
 * to be submitted to the chain)
 *
 * ## Returns
 * `c_uint` - Returns one of the following:
 *             0: Valid Block
 *             1: Valid Share
 *             2: Invalid Share
 *             3: Invalid Difficulty
 * `error_out` - Error code returned, 0 means no error
 *
 * # Safety
 * None
 */
int share_validate(struct ByteVector *header,
                   const char *hash,
                   unsigned int network,
                   unsigned long long share_difficulty,
                   unsigned long long template_difficulty,
                   int *error_out);

#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus
