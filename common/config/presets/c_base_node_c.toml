# A path to the file that stores your node identity and secret key (default = "config/base_node_id.json")
#identity_file = "config/base_node_id.json"

# Spin up and use a built-in Tor instance, only works on macos/linux and must comment out 'tor.control_address' below.
# This requires that the base node was built with the optional "libtor" feature flag. (default = true)
#use_libtor = false

# A path to the file that stores the tor hidden service private key, if using the tor transport.
# (default = "config/tor_id.json")
#tor_identity_file = "config/base_node_tor_id.json"

# The type of database backend to use. Currently supported options are "memory" and "lmdb". LMDB is recommnded for
# almost all use cases. (default = "lmdb")
#db_type = "lmdb"

# The relative path to store persistent data (default = "data/base_node")
#data_dir = "data/base_node"

# The relative path to store the lmbd data (default = "db")
#lmdb_path = "db"

# The maximum amount of VMs that RandomX will be use (default = 5)
#max_randomx_vms = 5

# Bypass range proof verification to speed up validation (default = false)
#bypass_range_proof_verification = false

# This allowlist provides a method to force syncing from any known nodes you may choose, for example if you have a
# couple of nodes that you always want to have in sync. If set this node will only sync to the nodes in this set.
# force_sync_peers = ["public_key1::address1", "public_key2::address2",... ]

# The maximum amount of seconds wait for remote base node responses for messaging-based requests.
#messaging_request_timeout = 60

# The time interval between status line updates in the CLI (default = 5 s)
#status_line_interval = 5

# The buffer size constants for the publish/subscribe connector channel, connecting comms messages to the domain layer:
# (min value = 30, default value = 1500).
#buffer_size = 1500

# Liveness meta data auto ping interval between peers (default = 30 s)
#metadata_auto_ping_interval = 30

# Obscure GRPC error responses (default = false)
#report_grpc_error = false

[base_node.lmdb]
#init_size_bytes = 16_777_216 # 16 *1024 * 1024
#grow_size_bytes = 16_777_216 # 16 *1024 * 1024
#resize_threshold_bytes = 4_194_304 # 4 *1024 * 1024

[base_node.storage]
# The maximum number of orphans that can be stored in the Orphan block pool.
#orphan_storage_capacity = 720
# The pruning horizon that is set for a default configuration of the blockchain db.
#pruning_horizon = 0
# The chain height interval used to determine when a pruned node should perform pruning.
#pruning_interval = 50
# Set to true to record all reorgs. Recorded reorgs can be viewed using the list-reorgs command. Default = false
track_reorgs = true
# Clean out
#cleanup_orphans_at_startup = false

[base_node.mempool]
# The maximum number of transactions that can be stored in the Unconfirmed Transaction pool
#unconfirmed_pool.storage_capacity = 40_000
# The maximum number of transactions that can be skipped when compiling a set of highest priority transactions,
# skipping over large transactions are performed in an attempt to fit more transactions into the remaining space.
#unconfirmed_pool.weight_tx_skip_count = 20
# The minimum fee accepted by the mempool
#unconfirmed_pool.min_fee = 0,

# The height horizon to clear transactions from the reorg pool.
#reorg_pool.expiry_height = 5

# Number of peers from which to initiate a sync. Once this many peers have successfully synced, this node will
# not initiate any more mempool syncs. Default: 2
#service.initial_sync_num_peers = 2
# The maximum number of transactions to sync in a single sync session Default: 10_000
#service.initial_sync_max_transactions = 10_000
# The maximum number of blocks added via sync or re-org to triggering a sync
#service.block_sync_trigger = 5

[base_node.state_machine]
# The initial max sync latency (seconds). If a peer fails to stream a header/block within this deadline another sync
# peer will be selected. If there are no further peers the sync will be restarted with an increased by
# `max_latency_increase`. [default = 240]
blockchain_sync_config.initial_max_sync_latency = 240
# If all sync peers exceed latency increase allowed latency by this value (seconds) [default = 10]
blockchain_sync_config.max_latency_increase = 10
# Longer ban period (seconds) for potentially malicious infractions (protocol violations etc.) [default = 2 hours]
#blockchain_sync_config.ban_period = 7_200 # 2 * 60 * 60
# Short ban period (seconds) for infractions that are likely not malicious (slow to respond spotty connections etc)
# [default = 4 minutes]
#blockchain_sync_config.short_ban_period = 240
# An allowlist of sync peers from which to sync. No other peers will be selected for sync. If empty sync peers
# are chosen based on their advertised chain metadata. [default = []]
#blockchain_sync_config.forced_sync_peers = []
# Number of threads to use for validation [default = 6]
#blockchain_sync_config.validation_concurrency = 6
# The RPC deadline to set on sync clients. If this deadline is reached, a new sync peer will be selected for sync.
# [default = 240]
blockchain_sync_config.rpc_deadline = 240

# The maximum amount of VMs that RandomX will be use (default = 0)
#max_randomx_vms = 0
# The amount of blocks this node can be behind a peer before considered to be lagging (to test the block
# propagation by delaying lagging, but also to give it time to receive the block via propagation, which is more network
# efficient)
# Note that time_before_considered_lagging will override this setting if the node sees a stronger chain for longer than
# that configured time.
# (default = 1)
#blocks_behind_before_considered_lagging = 1
# The amount of time this node can know about a stronger chain before considered to be lagging.
# This is to give a node time to receive the block via propagation, which is usually less network
# intensive. Be careful of setting this higher than the block time, which would potentially cause it
# to always be behind the network (default = 10) (in seconds)
#time_before_considered_lagging = 10
#This is the amount of metadata events that a node will wait for before decide to start syncing for a peer, choosing the best peer out of the list
#initial_sync_peer_count = 5,

[base_node.p2p]
# The node's publicly-accessible hostname. This is the host name that is advertised on the network so that
# peers can find you.
# _NOTE_: If using the `tor` transport type, public_addresses will be ignored and an onion address will be
# automatically configured
#public_addresses = ["/ip4/172.2.3.4/tcp/18189",]

# Optionally bind an additional TCP socket for inbound Tari P2P protocol commms.
# Use cases include:
# - allowing wallets to locally connect to their base node, rather than through tor, when used in conjunction with
#   `tor_proxy_bypass_addresses`
# - multiple P2P addresses, one public over DNS and one private over TOR
# - a "bridge" between TOR and TCP-only nodes
# auxiliary_tcp_listener_address = "/ip4/127.0.0.1/tcp/9998"

# Path to the LMDB data files
#datastore_path = "peer_db"

# Name to use for the peer database
#peer_database_name = "peers"

# The maximum number of concurrent Inbound tasks allowed before back-pressure is applied to peers
#max_concurrent_inbound_tasks = 4

# The maximum number of concurrent outbound tasks allowed before back-pressure is applied to outbound messaging queue
#max_concurrent_outbound_tasks = 4

# Set to true to allow peers to provide test addresses (loopback, memory etc.). If set to false, memory
# addresses, loopback, local-link (i.e addresses used in local tests) will not be accepted from peers. This
# should always be false for non-test nodes.
#allow_test_addresses = false

# CIDR for addresses allowed to enter into liveness check mode on the listener.
#listener_liveness_allowlist_cidrs = []

# The maximum simultaneous comms RPC sessions allowed (default value = 100). Setting this to -1 will allow unlimited
# sessions.
#rpc_max_simultaneous_sessions = 100
# The maximum comms RPC sessions allowed per peer (default value = 10).
#rpc_max_sessions_per_peer = 10
