########################################################################################################################
#                                                                                                                      #
#                                          Base Node Configuration Options                                             #
#                                                                                                                      #
########################################################################################################################

# If you are not running a Tari Base node, you can simply leave everything in this section commented out. Base nodes
# help maintain the security of the Tari token and are the surest way to preserve your privacy and be 100% sure that
# no-one is cheating you out of your money.

[base_node]
# network = "weatherwax"

# Configuration options for testnet Weatherwax
[base_node.weatherwax]
# The type of database backend to use. Currently supported options are "memory" and "lmdb". LMDB is recommnded for
# almost all use cases.
db_type = "lmdb"

# db config defaults
# db_init_size_mb = 1000
# db_grow_size_mb = 500
# db_resize_threshold_mb = 100

# The maximum number of orphans that can be stored in the Orphan block pool. Default value is "720".
#orphan_storage_capacity = 720
# The size that the orphan pool will be allowed to grow before it is cleaned out, with threshold being tested every
# time before fetch and add blocks. Default value is "0", which indicates the orphan pool will not be cleaned out.
#orphan_db_clean_out_threshold = 0
# The pruning horizon that indicates how many full blocks without pruning must be kept by the base node. Default value
# is "0", which indicates an archival node without any pruning.
#pruning_horizon = 0

# The amount of messages that will be permitted in the flood ban timespan of 100s (Default weatherwax = 1000,
# default mainnet = 10000)
flood_ban_max_msg_count = 10000

# The relative path to store persistent data
data_dir = "weatherwax"

# This allowlist provides a method to force syncing from any known nodes you may choose, for example if you have a
# couple of nodes that you always want to have in sync.
# force_sync_peers = ["public_key1::address1", "public_key2::address2",... ]
force_sync_peers = [
    #my known peer 1
    #"public_key1::address1",
    #my known peer 2
    #"public_key1::address1",
]

# Determines the method of syncing blocks when the node is lagging. If you are not struggling with syncing, then
# it is recommended to leave this setting as it. Available values are ViaBestChainMetadata and ViaRandomPeer.
#block_sync_strategy="ViaBestChainMetadata"

# Configure the maximum number of threads available for base node operation. These threads are spawned lazily, so a higher
# number is recommended.
# max_threads = 512

# The number of threads to spawn and keep active at all times. The default is the number of cores available on this node.
# core_threads = <number of cores>

# The node's publicly-accessible hostname. This is the host name that is advertised on the network so that
# peers can find you.
# _NOTE_: If using the `tor` transport type, public_address will be ignored and an onion address will be
# automatically configured
#public_address = "/ip4/172.2.3.4/tcp/18189"

# do we allow test addresses to be accpted like 127.0.0.1
allow_test_addresses = false

# Enable the gRPC server for the base node. Set this to true if you want to enable third-party wallet software
grpc_enabled = true
# The socket to expose for the gRPC base node server. This value is ignored if grpc_enabled is false.
# Valid values here are IPv4 and IPv6 TCP sockets, local unix sockets (e.g. "ipc://base-node-gprc.sock.100")
grpc_base_node_address = "127.0.0.1:18142"
# The socket to expose for the gRPC wallet server. This value is ignored if grpc_enabled is false.
# Valid values here are IPv4 and IPv6 TCP sockets, local unix sockets (e.g. "ipc://base-node-gprc.sock.100")
grpc_console_wallet_address = "127.0.0.1:18143"

# A path to the file that stores your node identity and secret key
base_node_identity_file = "config/base_node_id.json"

# A path to the file that stores your console wallet's node identity and secret key
console_wallet_identity_file = "config/console_wallet_id.json"

# -------------- Transport configuration --------------
# Use TCP to connect to the Tari network. This transport can only communicate with TCP/IP addresses, so peers with
# e.g. tor onion addresses will not be contactable.
#transport = "tcp"
# The address and port to listen for peer connections over TCP.
#tcp_listener_address = "/ip4/0.0.0.0/tcp/18189"
# Configures a tor proxy used to connect to onion addresses. All other traffic uses direct TCP connections.
# This setting is optional however, if it is not specified, this node will not be able to connect to nodes that
# only advertise an onion address.
#tcp_tor_socks_address = "/ip4/127.0.0.1/tcp/36050"
#tcp_tor_socks_auth = "none"

# Configures the node to run over a tor hidden service using the Tor proxy. This transport recognises ip/tcp,
# onion v2, onion v3 and dns addresses.
transport = "tor"
# Address of the tor control server
tor_control_address = "/ip4/127.0.0.1/tcp/9051"
# Authentication to use for the tor control server
tor_control_auth = "none" # or "password=xxxxxx"
# The onion port to use.
#tor_onion_port = 18141
# The address to which traffic on the node's onion address will be forwarded
# tor_forward_address = "/ip4/127.0.0.1/tcp/0"
# Instead of attemping to get the SOCKS5 address from the tor control port, use this one. The default is to
# use the first address returned by the tor control port (GETINFO /net/listeners/socks).
#tor_socks_address_override=

# Use a SOCKS5 proxy transport. This transport recognises any addresses supported by the proxy.
#transport = "socks5"
# The address of the SOCKS5 proxy
#socks5_proxy_address = "/ip4/127.0.0.1/tcp/9050"
# The address to which traffic will be forwarded
#socks5_listener_address = "/ip4/127.0.0.1/tcp/18189"
#socks5_auth = "none" # or "username_password=username:xxxxxxx"

# A path to the file that stores the tor hidden service private key, if using the tor transport.
base_node_tor_identity_file = "config/base_node_tor.json"

# A path to the file that stores the console wallet's tor hidden service private key, if using the tor transport.
console_wallet_tor_identity_file = "config/console_wallet_tor.json"

# Optionally bind an additional TCP socket for inbound Tari P2P protocol commms.
# Use cases include:
# - allowing wallets to locally connect to their base node, rather than through tor, when used in conjunction with `tor_proxy_bypass_addresses`
# - multiple P2P addresses, one public over DNS and one private over TOR
# - a "bridge" between TOR and TCP-only nodes
# auxilary_tcp_listener_address = "/ip4/127.0.0.1/tcp/9998"

# When these addresses are encountered when dialing another peer, the tor proxy is bypassed and the connection is made
# direcly over TCP. /ip4, /ip6, /dns, /dns4 and /dns6 are supported.
# tor_proxy_bypass_addresses = ["/dns4/my-foo-base-node/tcp/9998"]
# When using the tor transport and set to true, outbound TCP connections bypass the tor proxy. Defaults to false for better privacy
# tor_proxy_bypass_for_outbound_tcp = false;

########################################################################################################################
#                                                                                                                      #
#                                             Mempool Configuration Options                                            #
#                                                                                                                      #
########################################################################################################################
[mempool.weatherwax]

# The maximum number of transactions that can be stored in the Unconfirmed Transaction pool. This is the main waiting
# area in the mempool and almost all transactions will end up in this pool before being mined. It's for this reason
# that this parameter will have the greatest impact on actual memory usage by your mempool. If you are not mining,
# you can reduce this parameter to reduce memory consumption by your node, at the expense of network bandwith. For
# reference, a single block can hold about 4,000 transactions
# Default = 40,000 transactions
# unconfirmed_pool_storage_capacity = 40000

# The maximum number of transactions that can be stored in the Orphan Transaction pool. This pool keep transactions
# that are 'orphans', i.e. transactions with inputs that don't exist in the UTXO set. If you're not mining, and
# memory usage is a concern, this can safely be set to zero. Even so, orphan transactions do not appear that often
# (it's usually a short chain of spends that are broadcast in quick succession). The other potential source of orphan
# transactions are from DOS attacks and setting the `tx_ttl` parameter to a low value is an effective countermeasure
# in this case. Default: 250 transactions
# orphan_pool_storage_capacity = 250

# The maximum amount of time an orphan transaction will be permitted to stay in the mempool before being rejected.
# This should be set to a fairly long enough to allow the parent transaction to arrive; but low enough also to thwart
# DOS attacks. Default: 300 seconds
#orphan_tx_ttl = 300

# The maximum number of transactions that can be stored in the Pending Transaction pool. This pool holds transactions
# that are valid, but cannot be included in a block yet becuase there is a consensus rule holding it back, usually a
# time lock. Once the conditions holding the transaction in the pending pool are resolved, the transaction will move
# into the unconfirmed pool.  Default: 5,000 transactions
# pending_pool_storage_capacity = 5000

# The ReorgPool consists of all transactions that have recently been added to blocks.
# When a potential blockchain reorganization occurs the transactions can be recovered from the ReorgPool and can be
# added back into the UnconfirmedPool. Transactions in the ReOrg pool have a limited Time-to-live and will be removed
# from the pool when the Time-to-live thresholds is reached. Also, when the capacity of the pool has been reached, the
# oldest transactions will be removed to make space for incoming transactions. The pool capacity and TTL parameters
# have the same meaning as those for the pending pool, but applied to the reorg pool; obviously.
# Defaults: 10,000 transactions and 300 seconds
#reorg_pool_storage_capacity = 10_000
#reorg_tx_ttl = 300

# The maximum number of transactions that can be skipped when compiling a set of highest priority transactions,
# skipping over large transactions are performed in an attempt to fit more transactions into the remaining space.
# This parameter only affects mining nodes. You can ignore it if you are only running a base node. Even so, changing
# this parameter should not affect profitabilty in any meaningful way, since the transaction weights are selected to
# closely mirror how much block space they take up
#weight_tx_skip_count = 20

# Configuration options for testnet Igor
[base_node.igor]
# The type of database backend to use. Currently supported options are "memory" and "lmdb". LMDB is recommnded for
# almost all use cases.
db_type = "lmdb"

# db config defaults
# db_init_size_mb = 1000
# db_grow_size_mb = 500
# db_resize_threshold_mb = 100

# The maximum number of orphans that can be stored in the Orphan block pool. Default value is "720".
#orphan_storage_capacity = 720
# The size that the orphan pool will be allowed to grow before it is cleaned out, with threshold being tested every
# time before fetch and add blocks. Default value is "0", which indicates the orphan pool will not be cleaned out.
#orphan_db_clean_out_threshold = 0
# The pruning horizon that indicates how many full blocks without pruning must be kept by the base node. Default value
# is "0", which indicates an archival node without any pruning.
#pruning_horizon = 0

# The amount of messages that will be permitted in the flood ban timespan of 100s (Default weatherwax = 1000,
# default mainnet = 10000)
flood_ban_max_msg_count = 10000

# The relative path to store persistent data
data_dir = "igor"

# This allowlist provides a method to force syncing from any known nodes you may choose, for example if you have a
# couple of nodes that you always want to have in sync.
# force_sync_peers = ["public_key1::address1", "public_key2::address2",... ]
force_sync_peers = [
    #my known peer 1
    #"public_key1::address1",
    #my known peer 2
    #"public_key1::address1",
]

# Determines the method of syncing blocks when the node is lagging. If you are not struggling with syncing, then
# it is recommended to leave this setting as it. Available values are ViaBestChainMetadata and ViaRandomPeer.
#block_sync_strategy="ViaBestChainMetadata"

# Configure the maximum number of threads available for base node operation. These threads are spawned lazily, so a higher
# number is recommended.
# max_threads = 512

# The number of threads to spawn and keep active at all times. The default is the number of cores available on this node.
# core_threads = <number of cores>

# The node's publicly-accessible hostname. This is the host name that is advertised on the network so that
# peers can find you.
# _NOTE_: If using the `tor` transport type, public_address will be ignored and an onion address will be
# automatically configured
#public_address = "/ip4/172.2.3.4/tcp/18189"

# do we allow test addresses to be accpted like 127.0.0.1
allow_test_addresses = false

# Enable the gRPC server for the base node. Set this to true if you want to enable third-party wallet software
grpc_enabled = true
# The socket to expose for the gRPC base node server. This value is ignored if grpc_enabled is false.
# Valid values here are IPv4 and IPv6 TCP sockets, local unix sockets (e.g. "ipc://base-node-gprc.sock.100")
grpc_base_node_address = "127.0.0.1:18142"
# The socket to expose for the gRPC wallet server. This value is ignored if grpc_enabled is false.
# Valid values here are IPv4 and IPv6 TCP sockets, local unix sockets (e.g. "ipc://base-node-gprc.sock.100")
grpc_console_wallet_address = "127.0.0.1:18143"

# A path to the file that stores your node identity and secret key
base_node_identity_file = "config/base_node_id.json"

# A path to the file that stores your console wallet's node identity and secret key
console_wallet_identity_file = "config/console_wallet_id.json"

# -------------- Transport configuration --------------
# Use TCP to connect to the Tari network. This transport can only communicate with TCP/IP addresses, so peers with
# e.g. tor onion addresses will not be contactable.
#transport = "tcp"
# The address and port to listen for peer connections over TCP.
#tcp_listener_address = "/ip4/0.0.0.0/tcp/18189"
# Configures a tor proxy used to connect to onion addresses. All other traffic uses direct TCP connections.
# This setting is optional however, if it is not specified, this node will not be able to connect to nodes that
# only advertise an onion address.
#tcp_tor_socks_address = "/ip4/127.0.0.1/tcp/36050"
#tcp_tor_socks_auth = "none"

# Configures the node to run over a tor hidden service using the Tor proxy. This transport recognises ip/tcp,
# onion v2, onion v3 and dns addresses.
transport = "tor"
# Address of the tor control server
tor_control_address = "/ip4/127.0.0.1/tcp/9051"
# Authentication to use for the tor control server
tor_control_auth = "none" # or "password=xxxxxx"
# The onion port to use.
#tor_onion_port = 18141
# The address to which traffic on the node's onion address will be forwarded
# tor_forward_address = "/ip4/127.0.0.1/tcp/0"
# Instead of attemping to get the SOCKS5 address from the tor control port, use this one. The default is to
# use the first address returned by the tor control port (GETINFO /net/listeners/socks).
#tor_socks_address_override=

# Use a SOCKS5 proxy transport. This transport recognises any addresses supported by the proxy.
#transport = "socks5"
# The address of the SOCKS5 proxy
#socks5_proxy_address = "/ip4/127.0.0.1/tcp/9050"
# The address to which traffic will be forwarded
#socks5_listener_address = "/ip4/127.0.0.1/tcp/18189"
#socks5_auth = "none" # or "username_password=username:xxxxxxx"

# A path to the file that stores the tor hidden service private key, if using the tor transport.
base_node_tor_identity_file = "config/base_node_tor.json"

# A path to the file that stores the console wallet's tor hidden service private key, if using the tor transport.
console_wallet_tor_identity_file = "config/console_wallet_tor.json"

# Optionally bind an additional TCP socket for inbound Tari P2P protocol commms.
# Use cases include:
# - allowing wallets to locally connect to their base node, rather than through tor, when used in conjunction with `tor_proxy_bypass_addresses`
# - multiple P2P addresses, one public over DNS and one private over TOR
# - a "bridge" between TOR and TCP-only nodes
# auxilary_tcp_listener_address = "/ip4/127.0.0.1/tcp/9998"

# When these addresses are encountered when dialing another peer, the tor proxy is bypassed and the connection is made
# direcly over TCP. /ip4, /ip6, /dns, /dns4 and /dns6 are supported.
# tor_proxy_bypass_addresses = ["/dns4/my-foo-base-node/tcp/9998"]
# When using the tor transport and set to true, outbound TCP connections bypass the tor proxy. Defaults to false for better privacy
# tor_proxy_bypass_for_outbound_tcp = false;

########################################################################################################################
#                                                                                                                      #
#                                             Mempool Configuration Options                                            #
#                                                                                                                      #
########################################################################################################################
[mempool.igor]

# The maximum number of transactions that can be stored in the Unconfirmed Transaction pool. This is the main waiting
# area in the mempool and almost all transactions will end up in this pool before being mined. It's for this reason
# that this parameter will have the greatest impact on actual memory usage by your mempool. If you are not mining,
# you can reduce this parameter to reduce memory consumption by your node, at the expense of network bandwith. For
# reference, a single block can hold about 4,000 transactions
# Default = 40,000 transactions
# unconfirmed_pool_storage_capacity = 40000

# The maximum number of transactions that can be stored in the Orphan Transaction pool. This pool keep transactions
# that are 'orphans', i.e. transactions with inputs that don't exist in the UTXO set. If you're not mining, and
# memory usage is a concern, this can safely be set to zero. Even so, orphan transactions do not appear that often
# (it's usually a short chain of spends that are broadcast in quick succession). The other potential source of orphan
# transactions are from DOS attacks and setting the `tx_ttl` parameter to a low value is an effective countermeasure
# in this case. Default: 250 transactions
# orphan_pool_storage_capacity = 250

# The maximum amount of time an orphan transaction will be permitted to stay in the mempool before being rejected.
# This should be set to a fairly long enough to allow the parent transaction to arrive; but low enough also to thwart
# DOS attacks. Default: 300 seconds
#orphan_tx_ttl = 300

# The maximum number of transactions that can be stored in the Pending Transaction pool. This pool holds transactions
# that are valid, but cannot be included in a block yet becuase there is a consensus rule holding it back, usually a
# time lock. Once the conditions holding the transaction in the pending pool are resolved, the transaction will move
# into the unconfirmed pool.  Default: 5,000 transactions
# pending_pool_storage_capacity = 5000

# The ReorgPool consists of all transactions that have recently been added to blocks.
# When a potential blockchain reorganization occurs the transactions can be recovered from the ReorgPool and can be
# added back into the UnconfirmedPool. Transactions in the ReOrg pool have a limited Time-to-live and will be removed
# from the pool when the Time-to-live thresholds is reached. Also, when the capacity of the pool has been reached, the
# oldest transactions will be removed to make space for incoming transactions. The pool capacity and TTL parameters
# have the same meaning as those for the pending pool, but applied to the reorg pool; obviously.
# Defaults: 10,000 transactions and 300 seconds
#reorg_pool_storage_capacity = 10_000
#reorg_tx_ttl = 300

# The maximum number of transactions that can be skipped when compiling a set of highest priority transactions,
# skipping over large transactions are performed in an attempt to fit more transactions into the remaining space.
# This parameter only affects mining nodes. You can ignore it if you are only running a base node. Even so, changing
# this parameter should not affect profitabilty in any meaningful way, since the transaction weights are selected to
# closely mirror how much block space they take up
#weight_tx_skip_count = 20
